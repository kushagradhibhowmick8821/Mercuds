"""
Traffic Analyzer Module
Detects anomalies and suspicious patterns in network traffic
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Optional
from enum import Enum
import statistics


class ThreatLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Alert:
    """Security alert generated by the analyzer"""
    timestamp: datetime
    alert_type: str
    threat_level: ThreatLevel
    source_ip: str
    destination_ip: Optional[str]
    description: str
    details: dict = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "timestamp": self.timestamp.isoformat(),
            "alert_type": self.alert_type,
            "threat_level": self.threat_level.value,
            "source_ip": self.source_ip,
            "destination_ip": self.destination_ip,
            "description": self.description,
            "details": self.details
        }


class TrafficAnalyzer:
    """
    Analyzes network traffic for suspicious patterns and anomalies
    """
    
    # Common suspicious ports
    SUSPICIOUS_PORTS = {
        4444: "Metasploit default",
        5555: "Android ADB",
        6666: "IRC backdoor",
        6667: "IRC (often C2)",
        31337: "Back Orifice",
        12345: "NetBus",
        27374: "SubSeven",
        1337: "Common backdoor",
    }
    
    # Ports that shouldn't have much outbound traffic
    WATCH_PORTS = {22, 23, 3389, 5900, 445, 139}  # SSH, Telnet, RDP, VNC, SMB
    
    def __init__(self):
        # Connection tracking
        self.connections = defaultdict(lambda: {
            "count": 0,
            "first_seen": None,
            "last_seen": None,
            "ports": set(),
            "bytes": 0
        })
        
        # Per-IP statistics
        self.ip_stats = defaultdict(lambda: {
            "packets_sent": 0,
            "packets_received": 0,
            "bytes_sent": 0,
            "bytes_received": 0,
            "unique_destinations": set(),
            "unique_ports": set(),
            "protocols": defaultdict(int)
        })
        
        # Time-based tracking for rate detection
        self.time_windows = defaultdict(list)  # IP -> list of timestamps
        
        # Alert storage
        self.alerts: list[Alert] = []
        
        # Thresholds (configurable)
        self.thresholds = {
            "port_scan_threshold": 20,      # Unique ports in 60 seconds
            "connection_rate_threshold": 50, # Connections per minute
            "data_exfil_threshold": 10_000_000,  # 10MB outbound to single IP
            "time_window_seconds": 60
        }
        
        # Baseline (will be learned)
        self.baseline = {
            "normal_packet_rate": None,
            "normal_connection_rate": None,
            "known_hosts": set()
        }
    
    def analyze_packet(self, packet_info) -> list[Alert]:
        """
        Analyze a single packet and return any generated alerts
        """
        alerts = []
        src_ip = packet_info.src_ip
        dst_ip = packet_info.dst_ip
        
        # Update statistics
        self._update_stats(packet_info)
        
        # Run detection modules
        alerts.extend(self._detect_port_scan(packet_info))
        alerts.extend(self._detect_suspicious_ports(packet_info))
        alerts.extend(self._detect_connection_flood(packet_info))
        alerts.extend(self._detect_data_exfiltration(packet_info))
        alerts.extend(self._detect_protocol_anomalies(packet_info))
        
        # Store alerts
        self.alerts.extend(alerts)
        
        return alerts
    
    def _update_stats(self, packet_info):
        """Update internal statistics"""
        src_ip = packet_info.src_ip
        dst_ip = packet_info.dst_ip
        now = datetime.now()
        
        # Update connection tracking
        conn_key = f"{src_ip}->{dst_ip}"
        conn = self.connections[conn_key]
        conn["count"] += 1
        conn["last_seen"] = now
        if conn["first_seen"] is None:
            conn["first_seen"] = now
        if packet_info.dst_port:
            conn["ports"].add(packet_info.dst_port)
        conn["bytes"] += packet_info.length
        
        # Update IP stats
        self.ip_stats[src_ip]["packets_sent"] += 1
        self.ip_stats[src_ip]["bytes_sent"] += packet_info.length
        self.ip_stats[src_ip]["unique_destinations"].add(dst_ip)
        if packet_info.dst_port:
            self.ip_stats[src_ip]["unique_ports"].add(packet_info.dst_port)
        self.ip_stats[src_ip]["protocols"][packet_info.protocol] += 1
        
        self.ip_stats[dst_ip]["packets_received"] += 1
        self.ip_stats[dst_ip]["bytes_received"] += packet_info.length
        
        # Time window tracking
        self.time_windows[src_ip].append(now)
        # Clean old entries
        cutoff = now - timedelta(seconds=self.thresholds["time_window_seconds"])
        self.time_windows[src_ip] = [t for t in self.time_windows[src_ip] if t > cutoff]
    
    def _detect_port_scan(self, packet_info) -> list[Alert]:
        """Detect port scanning behavior"""
        alerts = []
        src_ip = packet_info.src_ip
        dst_ip = packet_info.dst_ip
        
        # Check unique ports accessed in time window
        conn_key = f"{src_ip}->{dst_ip}"
        conn = self.connections[conn_key]
        
        if len(conn["ports"]) >= self.thresholds["port_scan_threshold"]:
            # Check if we already alerted for this
            recent_alerts = [a for a in self.alerts 
                          if a.alert_type == "PORT_SCAN" 
                          and a.source_ip == src_ip
                          and a.destination_ip == dst_ip
                          and (datetime.now() - a.timestamp).seconds < 300]
            
            if not recent_alerts:
                alerts.append(Alert(
                    timestamp=datetime.now(),
                    alert_type="PORT_SCAN",
                    threat_level=ThreatLevel.HIGH,
                    source_ip=src_ip,
                    destination_ip=dst_ip,
                    description=f"Possible port scan detected: {len(conn['ports'])} unique ports",
                    details={
                        "ports_scanned": len(conn["ports"]),
                        "sample_ports": list(conn["ports"])[:10]
                    }
                ))
        
        return alerts
    
    def _detect_suspicious_ports(self, packet_info) -> list[Alert]:
        """Detect connections to known suspicious ports"""
        alerts = []
        
        if packet_info.dst_port in self.SUSPICIOUS_PORTS:
            alerts.append(Alert(
                timestamp=datetime.now(),
                alert_type="SUSPICIOUS_PORT",
                threat_level=ThreatLevel.MEDIUM,
                source_ip=packet_info.src_ip,
                destination_ip=packet_info.dst_ip,
                description=f"Connection to suspicious port {packet_info.dst_port}",
                details={
                    "port": packet_info.dst_port,
                    "reason": self.SUSPICIOUS_PORTS[packet_info.dst_port],
                    "protocol": packet_info.protocol
                }
            ))
        
        return alerts
    
    def _detect_connection_flood(self, packet_info) -> list[Alert]:
        """Detect connection flooding / DDoS patterns"""
        alerts = []
        src_ip = packet_info.src_ip
        
        # Check connection rate
        recent_connections = len(self.time_windows[src_ip])
        
        if recent_connections >= self.thresholds["connection_rate_threshold"]:
            recent_alerts = [a for a in self.alerts 
                          if a.alert_type == "CONNECTION_FLOOD" 
                          and a.source_ip == src_ip
                          and (datetime.now() - a.timestamp).seconds < 60]
            
            if not recent_alerts:
                alerts.append(Alert(
                    timestamp=datetime.now(),
                    alert_type="CONNECTION_FLOOD",
                    threat_level=ThreatLevel.HIGH,
                    source_ip=src_ip,
                    destination_ip=None,
                    description=f"High connection rate: {recent_connections}/min",
                    details={
                        "connections_per_minute": recent_connections,
                        "threshold": self.thresholds["connection_rate_threshold"]
                    }
                ))
        
        return alerts
    
    def _detect_data_exfiltration(self, packet_info) -> list[Alert]:
        """Detect potential data exfiltration"""
        alerts = []
        src_ip = packet_info.src_ip
        dst_ip = packet_info.dst_ip
        
        conn_key = f"{src_ip}->{dst_ip}"
        bytes_sent = self.connections[conn_key]["bytes"]
        
        if bytes_sent >= self.thresholds["data_exfil_threshold"]:
            recent_alerts = [a for a in self.alerts 
                          if a.alert_type == "DATA_EXFILTRATION" 
                          and a.source_ip == src_ip
                          and a.destination_ip == dst_ip
                          and (datetime.now() - a.timestamp).seconds < 300]
            
            if not recent_alerts:
                alerts.append(Alert(
                    timestamp=datetime.now(),
                    alert_type="DATA_EXFILTRATION",
                    threat_level=ThreatLevel.CRITICAL,
                    source_ip=src_ip,
                    destination_ip=dst_ip,
                    description=f"Large data transfer: {bytes_sent / 1_000_000:.2f} MB",
                    details={
                        "bytes_transferred": bytes_sent,
                        "threshold_mb": self.thresholds["data_exfil_threshold"] / 1_000_000
                    }
                ))
        
        return alerts
    
    def _detect_protocol_anomalies(self, packet_info) -> list[Alert]:
        """Detect protocol-level anomalies"""
        alerts = []
        
        # Detect DNS tunneling (unusually large DNS packets)
        if packet_info.protocol == "DNS" and packet_info.length > 512:
            alerts.append(Alert(
                timestamp=datetime.now(),
                alert_type="DNS_ANOMALY",
                threat_level=ThreatLevel.MEDIUM,
                source_ip=packet_info.src_ip,
                destination_ip=packet_info.dst_ip,
                description=f"Oversized DNS packet ({packet_info.length} bytes) - possible DNS tunneling",
                details={
                    "packet_size": packet_info.length,
                    "normal_max": 512
                }
            ))
        
        # Detect ICMP tunneling (large ICMP packets)
        if packet_info.protocol == "ICMP" and packet_info.length > 1000:
            alerts.append(Alert(
                timestamp=datetime.now(),
                alert_type="ICMP_ANOMALY",
                threat_level=ThreatLevel.MEDIUM,
                source_ip=packet_info.src_ip,
                destination_ip=packet_info.dst_ip,
                description=f"Large ICMP packet ({packet_info.length} bytes) - possible ICMP tunneling",
                details={
                    "packet_size": packet_info.length
                }
            ))
        
        return alerts
    
    def get_summary(self) -> dict:
        """Get analysis summary"""
        return {
            "total_connections": len(self.connections),
            "unique_ips": len(self.ip_stats),
            "total_alerts": len(self.alerts),
            "alerts_by_type": self._count_alerts_by_type(),
            "alerts_by_severity": self._count_alerts_by_severity(),
            "top_talkers": self._get_top_talkers(5)
        }
    
    def _count_alerts_by_type(self) -> dict:
        counts = defaultdict(int)
        for alert in self.alerts:
            counts[alert.alert_type] += 1
        return dict(counts)
    
    def _count_alerts_by_severity(self) -> dict:
        counts = defaultdict(int)
        for alert in self.alerts:
            counts[alert.threat_level.value] += 1
        return dict(counts)
    
    def _get_top_talkers(self, n: int) -> list[dict]:
        """Get top N IPs by traffic volume"""
        ip_traffic = []
        for ip, stats in self.ip_stats.items():
            total = stats["bytes_sent"] + stats["bytes_received"]
            ip_traffic.append({"ip": ip, "total_bytes": total})
        
        ip_traffic.sort(key=lambda x: x["total_bytes"], reverse=True)
        return ip_traffic[:n]
